"""Generate a coronal view of data"""
import bg_space
import yaml
import flexiznam as flz
from skimage.measure import regionprops
from skimage.morphology import disk
from skimage.filters import median as skmedian
import numpy as np
import pandas as pd
import PIL
import tifffile
from cricksaw_analysis import atlas_utils
from flexiznam.schema import Dataset
from imlib.cells.utils import get_cell_location_array
from matplotlib import pyplot as plt
from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar

# ensure txt is exported as txt in svg files:
plt.rcParams["svg.fonttype"] = "none"


def get_cell_data(mouse, flm_sess, bg_atlas):
    """Get cellfinder data from flexilims

    Args:
        mouse (str): Name of the mouse
        flm_sess (flexilims.Session): Flexilims session to access the database
        bg_atlas (bg_atlasapi.bg_atlas.BrainGlobeAtlas): Brainglobe atlas object

    Returns:
        cellfinder_data (flexiznam.schema.datasets.Dataset): Flexilims dataset
        cells (numpy.array): N cells x 3 array of cell coordinates in raw data
        atlas_coord (numpy.array): N cells x 3 array of cell coordinates in atlas
        atlas_id (numpy.array): N cells array of atlas area IDs
    """
    # find the dataset on flexilims
    children = flz.get_children(
        mouse.id, flexilims_session=flm_sess, children_datatype="dataset"
    )
    if not len(children):
        raise IOError("No datasets found")
    cellfinder_data = children[
        (children.dataset_type == "cellfinder")
        & (children.atlas == bg_atlas.atlas_name)
    ]
    if len(cellfinder_data) > 1:
        raise IOError("Got %d cellfinder datasets" % len(cellfinder_data))
    cellfinder_data = Dataset.from_flexilims(data_series=cellfinder_data.iloc[0])

    cells = get_cell_location_array(
        str(cellfinder_data.path_full / "points" / "cell_classification.xml"),
        cells_only=True,
    )
    atlas_coord = pd.read_hdf(
        cellfinder_data.path_full / "points" / "atlas.points"
    ).values
    rd = np.array(np.round(atlas_coord), dtype=int)
    atlas_id = bg_atlas.annotation[rd[:, 0], rd[:, 1], rd[:, 2]]
    return cellfinder_data, cells, atlas_coord, atlas_id


def load_in_brainsaw_coordinates(
    source_file,
    source_origin=("Anterior", "Superior", "Right"),
    target_origin=("Posterior", "Superior", "Left"),
):
    """Load 3D volume generated by cellfinder in brainsaw coordinates

    Args:
        source_file (str or pathlibe.Path): Path to 3D volume
        source_origin (tuple, optional): Origin position in brainglobe coordinates.
            Defaults to ("Anterior", "Superior", "Right").
        target_origin (tuple, optional): Origin position in brainsaw coordinates.
            Defaults to ("Posterior", "Superior", "Left").

    Returns:
        numpy.array: 3D volume in brainsaw coordinates
    """
    data_in_bg_coordinates = tifffile.imread(source_file)
    data_in_brainsaw_coordinates = bg_space.map_stack_to(
        source_origin, target_origin, data_in_bg_coordinates, copy=False
    )
    return data_in_brainsaw_coordinates


def make_rgb_image(best_plane, plane_per_section, raw_data_dir, projection_func):
    """Make RGB image from raw data

    Will project the raw data from one whole physical section into a single image using
    projection_func.

    R is the red channel from cricksaw, G and B are both set to the green channel.
    Args:
        best_plane (int): Plane number of the best section
        plane_per_section (int): Number of planes per section
        raw_data_dir (str): Path to raw data
        projection_func (func): Function to use for projection, must have an axis
            argument

    Returns:
        numpy array: RGB image of the best section
    """
    best_slice = best_plane // plane_per_section

    img_data = dict()
    for channel in [2, 3]:
        chan_dir = raw_data_dir / str(channel)
        assert chan_dir.is_dir()
        for zslice in range(plane_per_section):
            tif = chan_dir / ("section_%03d_%02d.tif" % (best_slice + 1, zslice + 1))
            tif = tifffile.imread(tif)
            if channel not in img_data:
                img_data[channel] = np.zeros(list(tif.shape) + [5], dtype=tif.dtype)
            img_data[channel][:, :, zslice] = tif

    for channel in [2, 3]:
        img_data[channel] = projection_func(img_data[channel], axis=2)
    rgb = np.zeros(list(img_data[3].shape) + [3], dtype=np.uint8)
    contrast = np.percentile(img_data[3], [0, 99.9])
    red = np.array((img_data[3] - contrast[0]) / np.diff(contrast) * 255)
    red = np.clip(red, 0, 255)
    red = np.array(red, dtype=np.uint8)
    contrast = np.percentile(img_data[2], [5, 99.99])
    green = np.array((img_data[2] - contrast[0]) / np.diff(contrast) * 255)
    green = np.clip(green, 0, 255)
    green = np.array(green, dtype=np.uint8)
    rgb[:, :, 0] = red
    rgb[:, :, 1] = green
    rgb[:, :, 2] = green
    return rgb


def get_cricksaw_metadata(raw_data_dir):
    """Get metadata from cricksaw recipe

    Args:
        raw_data_dir (pathlib.Path): Path to raw data directory

    Returns:
        dict: Dictionary of metadata information
    """
    recipe_file = list(raw_data_dir.parent.glob("recipe_*.yml"))
    if not len(recipe_file):
        return None
    if len(recipe_file) != 1:
        raise IOError("Found %d recipe files" % len(recipe_file))
    with open(recipe_file[0]) as f:
        recipe = yaml.safe_load(f)
    return recipe


def plot_area(
    ax,
    raw_data_dir,
    area,
    bg_atlas,
    atlas_id,
    cells,
    mouse_prop,
    atlas_volume,
    projection_func=np.max,
    add_detected_cells=True,
):
    """Plot a coronal view of the data

    Args:
        ax (matplotlib.Axes): Axes to plot on
        raw_data_dir (str): Path to the `stitchedImage_100` directory
        area (str): Name of the parent area. Used for reading limits in mouse_prop
        bg_atlas (brainglobeatlas): Brainglobe atlas object
        atlas_id (numpy.array): N cells array of atlas area IDs
        cells (numpy.array): N cells x 3 array of cell coordinates in raw data
        mouse_prop (dict): Properties to adjust the plot for each area
        atlas_volume (numpy array): 3D volume of the atlas
        projection_func (func, optional): Function used to project the data across
            optical sections. Defaults to np.max.
        add_detected_cells (bool, optional): Add scatter plot of detect cells to the
            image. Defaults to True.
    """
    metadata = get_cricksaw_metadata(raw_data_dir)
    pixel_size = metadata["VoxelSize"]["X"]
    z_resolution = metadata["VoxelSize"]["Z"]
    plane_per_section = int(metadata["mosaic"]["numOpticalPlanes"])

    # define axis orientation
    ap_axis, dv_axis, ml_axis = (2, 1, 0)

    # get area and subareas ids
    area_names = [area] + bg_atlas.get_structure_descendants(area)
    area_ids = [bg_atlas.structures.acronym_to_id_map[a] for a in area_names]

    # get the best plane, use either the manually defined or that with the most cells
    # filter cells
    ok_cells = np.isin(atlas_id, area_ids)
    if area in mouse_prop:
        best_plane = mouse_prop[area]["z"]
    else:
        ok_planes = np.round(cells[ok_cells, ap_axis])
        plane_count = pd.value_counts(ok_planes)
        best_plane = plane_count.sort_values().index[-1]

    # get the rbg image for this plane
    rgb = make_rgb_image(best_plane, plane_per_section, raw_data_dir, projection_func)

    # get the label image for the corresponding atlas plane
    zatlas = int(best_plane * z_resolution / bg_atlas.resolution[0])
    label_img = PIL.Image.fromarray(atlas_volume[zatlas, :, :])
    label_img = np.asarray(
        label_img.resize(rgb.shape[1::-1], resample=PIL.Image.Resampling.NEAREST)
    )
    label_img = skmedian(label_img, disk(7))
    if area in mouse_prop:
        prop = mouse_prop[area]
        # bbox is (min_row, min_col, max_row, max_col)
        bounding_box = [
            prop["ylim"][0],
            prop["xlim"][0],
            prop["ylim"][1],
            prop["xlim"][1],
        ]
    else:
        # Get mask of region
        mask = np.isin(label_img, area_ids).astype("uint8")
        region = regionprops(mask)
        # Get bounding box of first (only) region in the image
        bounding_box = region[0].bbox
    # crop img_data
    xlims = [bounding_box[1], bounding_box[3]]
    ylims = [bounding_box[0], bounding_box[2]]
    rgb = rgb[slice(*ylims), slice(*xlims), :]
    label_img = label_img[slice(*ylims), slice(*xlims)]

    ax.imshow(rgb)

    o = atlas_utils.plot_borders_and_areas(
        ax,
        label_img,
        areas_to_plot=[],
        color_kwargs=dict(),
        border_kwargs=dict(colors="white", linewidths=0.1, linestyles="dashed"),
        label_atlas=bg_atlas,
    )

    if add_detected_cells:
        in_plane = np.abs(cells[:, ap_axis] - best_plane) < 5
        ax.plot(
            cells[in_plane, ml_axis],
            cells[in_plane, dv_axis],
            "o",
            alpha=0.2,
            mfc="none",
            mec="k",
        )
        ax.plot(
            cells[np.logical_and(ok_cells, in_plane), ml_axis],
            cells[np.logical_and(ok_cells, in_plane), dv_axis],
            "o",
            color="lime",
            alpha=0.1,
            ms=3,
        )
        ax.set_title(area)

    # add a scale bar
    scale_bar = AnchoredSizeBar(
        ax.get_xaxis_transform(),
        size=500 / pixel_size,
        label=r"$500\mu m$",
        loc="lower right",
        color="white",
        frameon=False,
        size_vertical=0.01,
    )
    ax.add_artist(scale_bar)
    ax.set_aspect("equal")
    ax.set_axis_off()
